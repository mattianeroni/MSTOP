"""
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This file is part of the collaboration with Universitat Oberta de Catalunya (UOC) on
Multi-Source Team Orienteering Problem (MSTOP).
The objective of the project is to develop an efficient algorithm to solve this extension
of the classic team orienteering problem, in which the vehicles / paths may start from
several different sources.

Author: Mattia Neroni, Ph.D., Eng.
Contact: mneroni@uoc.edu
Date: January 2022
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
"""
import numpy as np
import random
import functools
import collections
import heapq

from iterators import greedy, BRA
from mapper import mapper
from pjs import PJS, PJS_cache, multistartPJS



def set_savings (problem, alpha=0.3):
    """
    This method calculate the saving of edges according to the given alpha.

    NOTE: Edges are modified in place.

    :param problem: The instance of the problem to solve.
    :param alpha: The alpha parameter of the PJS.
    :return: The problem instance modified in place.
    """
    dists, depot = problem.dists, problem.depot
    for edge in problem.edges:
        cost, inode, jnode = edge.cost, edge.inode, edge.jnode
        revenue = inode.revenue + jnode.revenue
        edge.savings = {
            source.id : (1.0 - alpha)*(dists[inode.id, depot.id] + dists[source.id, jnode.id] - cost) + alpha*revenue
        for source in problem.sources}
    return problem





def alpha_optimisation (problem, alpha_range=np.arange(0.0, 1.1, 0.1)):
    """
    This method is used to optimise the alpha parameter.
    Alpha parameter is used in the calculation of edges savings:

        saving = distance_saving * (1 - alpha) + revenue * alpha

    The higher is alpha the bigger is the importance of the revenue,
    the lower is alpha the bigger is the importance of the distance saving.


    We basically run 10 deterministic executions of the algorithm
    (i.e., Mapper and then PJS) for 10 different levels of alpha.
    The value of alpha that provides the best deterministic solution
    is kept.

    NOTE: This method also changes in place the savings of the edges.

    :param problem: The problem instance to solve .
    :param alpha_range: The levels of alpha to test.
    :return: The best value obtained for alpha.
    """
    # Move useful references to the stack
    dists, depot, sources, nodes = problem.dists, problem.depot, problem.sources, problem.nodes
    # Run once the deterministic mapper
    mapping = mapper(problem, iterator=greedy)

    # Initialise the best alpha to zero
    best_alpha, best_revenue = 0.0, float("-inf")

    # We try different values of alpha parameter and we keep the best
    for alphatest in alpha_range:
        # Tray a new value of alpha
        alphatest = round(alphatest, 1)
        # Compute the edges savings according to the new alpha value
        set_savings(problem, alphatest)
        # Run a deterministic version of the PJS algorithm for each source.
        routes = []
        for source in problem.sources:
            partial_routes = PJS_cache(problem, source, tuple(source.nodes), depot, alphatest)
            routes.extend(partial_routes)
        # Total obtained revenue (i.e., quality of the solution)
        total_revenue = sum(r.revenue for r in routes)
        # Eventually update the alpha
        if total_revenue > best_revenue:
            best_alpha, best_revenue = alphatest, total_revenue
    # Set the savings of the edges by using the best found alpha
    set_savings(problem, best_alpha)
    # Return the best alpha obtained
    return best_alpha




def heuristic (problem, iterator, alpha):
    """
    This is the main executiom of the solver.
    It can be deterministic of stochastic depending on the iterator
    passed as argument.

    :param problem: The problem instance to solve.
    :param iterator: The iterator to be passed to the mapper.
    :param alpha: The alpha value used to calculate edges savings (used only for caching)
    :return: The solution as a set of routes, their total revenue, the mapping represented a matrix.
    """
    # Mapping
    mapping = mapper(problem, iterator)
    # PJS on routes
    routes = []
    for source in problem.sources:
        r = PJS_cache(problem, source, tuple(source.nodes), problem.depot, alpha)
        routes.extend(r)
    # Calculate total revenue
    revenue = sum(r.revenue for r in routes)
    # Return the mapping, the routes and the revenue
    return revenue, mapping, tuple(routes)




def multistart (problem, alpha, maxiter=1000, betarange=(0.1, 0.3)):
    """
    This is the multistart execution of the PJS algorithm.
    At each iteration a new solution is generated by introducing
    slight modifications through a biased randomised approach.
    The new generated solution is compared to the best one and
    eventually replace them (if the revenue obtained is higher).

    :param problem: The problem instance to solve.
    :param alpha: The alpha value used to calculate edges savings (used only for caching)
    :param maxiter: The maximum number of iterations and different
                    mapping tested.
    :param betarange: The range of the beta parameter to use in the biased randomisation.

    :return: The best solution found so far with the respective mapping and revenue.
    """
    # Check the values provided for the beta parameter
    if betarange[0] > betarange[1]:
        raise Exception("Min beta should be higher than max beta.")

    # Save beta ranges
    minbeta, maxbeta = betarange

    # Initialise the starting solution as the greedy one
    brevenue, bmapping, broutes = heuristic(problem, iterator=greedy, alpha=alpha)

    # Iterated Local Search
    for i in range(maxiter):

        # Initialise the biased randomised iterator
        _bra = functools.partial(BRA, beta=random.uniform(minbeta, maxbeta))

        # Generate a new solution
        revenue, mapping, routes = heuristic(problem, iterator=_bra, alpha=alpha)

        # Eventually update the best
        if revenue > brevenue:
            brevenue, bmapping, broutes = revenue, mapping, routes

    # Return the best solution found so far
    return brevenue, bmapping, broutes




def multistart_keep_elites (problem, alpha, maxiter=1000, betarange=(0.1, 0.3), nelites=5):
    """
    Same as the multistart, but instead of saving just the best solution, we keep
    track of the nelites best ones storing them in a heap.

    :param problem: The problem instance to solve.
    :param alpha: The alpha value used to calculate edges savings (used only for caching)
    :param maxiter: The maximum number of iterations and different
                    mapping tested.
    :param betarange: The range of the beta parameter to use in the biased randomisation.
    :param nelites: The number of elite solutions we keep in memory.

    :return: The best solution found so far with the respective mapping and revenue.
    """
    # Check the values provided for the beta parameter
    if betarange[0] > betarange[1]:
        raise Exception("Min beta should be higher than max beta.")

    # Save beta ranges
    minbeta, maxbeta = betarange

    # Initialise the heap of the best solutions
    bestsolutions = []

    # Initialise the count of insered solutions to avoid comparison of not comparable
    # elements into the heap
    count = 0

    # Initialise the starting solution as the greedy one (i.e., brevenue, bmapping, broutes)
    revenue, routes, mapping = heuristic(problem, iterator=greedy, alpha=alpha)

    # Update the heap
    heapq.heappush(bestsolutions, (revenue, count, routes, mapping ))
    count += 1

    # Iterated Local Search
    for i in range(maxiter):

        # Initialise the biased randomised iterator
        _bra = functools.partial(BRA, beta=random.uniform(minbeta, maxbeta))

        # Generate a new solution (i.e., revenue, mapping, routes)
        revenue, routes, mapping = heuristic(problem, iterator=_bra, alpha=alpha)

        # Eventually update the best
        if len(bestsolutions) == nelites and revenue > bestsolutions[0][0]:
            heapq.heappushpop(bestsolutions, (revenue, count, routes, mapping))
            count += 1

        # Update the heap if its capacity is not saturated
        if len(bestsolutions) < nelites:
            heapq.heappush(bestsolutions, (revenue, count, routes, mapping))
            count += 1

    # Return the best solution found so far
    return tuple(bestsolutions)



def optimise_elites (problem, elites, alpha, maxiter=1000, betarange=(0.1, 0.3)):
    """
    This process is used to optimise the elite solutions using a multistart PJS.

    :param problem: The problem instance to solve.
    :param elites: The elite solutions presented as sets of routes.
    :param alpha: The alpha value used to calculate edges savings (used only for caching)
    :param maxiter: The number of solutions explored.
    :param betarange: The range of beta used for the generation of different solutions
                        with a biased randomised approach.
    :return: The best solution chosen among the optimised elites.
    """
    # Initialise the current best
    bestroutes, bestrevenue, bestmapping = elites[0][3], elites[0][0], elites[0][2]

    S = len(problem.sources)

    for _, _, mapping, _ in elites:

        # Init the optimised routes and revenue
        total_routes, total_revenue = [], 0

        # Run a multi start PJS on each group of nodes assigned to a single source
        for i, source in enumerate(problem.sources):

            nodes = tuple(node for node, v in zip(problem.nodes, mapping[i, S:]) if v == 1)

            routes, revenue = multistartPJS(problem, source, nodes, problem.depot, alpha, maxiter, betarange)

            total_routes.extend(routes)
            total_revenue += revenue

        # Eventually update the best
        if total_revenue > bestrevenue:
            bestroutes, bestrevenue, bestmapping = total_routes, total_revenue, mapping

    # Return the best routes, revenue, and mapping
    return bestrevenue, bestmapping, tuple(bestroutes)
